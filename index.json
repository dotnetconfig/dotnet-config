{
  "api/DotNetConfig.Config.html": {
    "href": "api/DotNetConfig.Config.html",
    "title": "Class Config | .netconfig",
    "keywords": "Class Config Provides access to .netconfig configuration options. Inheritance System.Object Config Namespace : DotNetConfig Assembly : cs.temp.dll.dll Syntax public abstract class Config : IEnumerable<ConfigEntry> Constructors Config(String) Creates the Config and sets FilePath to the given filePath . Declaration protected Config(string filePath) Parameters Type Name Description System.String filePath Fields FileName Default filename, equal to '.netconfig'. Declaration public const string FileName = \".netconfig\" Field Value Type Description System.String Properties FilePath Path to the file that will be used to save values when writing changes to disk. Declaration public string FilePath { get; } Property Value Type Description System.String GlobalLocation Default global location, equal to System.Environment.SpecialFolder.UserProfile plus FileName . Declaration public static string GlobalLocation { get; } Property Value Type Description System.String Level Gets the optional configuration level for this config. null unless the FilePath equals GlobalLocation or SystemLocation or it ends in .user in which case it's Local . Declaration public ConfigLevel? Level { get; } Property Value Type Description System.Nullable < ConfigLevel > SystemLocation Default system location, equal to System.Environment.SpecialFolder.System plus FileName . Declaration public static string SystemLocation { get; } Property Value Type Description System.String Methods AddBoolean(String, String, String, Boolean) Adds a value to a multi-valued variable in the given section and optional subsection. Declaration public abstract Config AddBoolean(string section, string subsection, string variable, bool value) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.Boolean value Value add to the variable. Returns Type Description Config AddDateTime(String, String, String, DateTime) Adds a value to a multi-valued variable in the given section and optional subsection. Declaration public abstract Config AddDateTime(string section, string subsection, string variable, DateTime value) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.DateTime value Value add to the variable. Returns Type Description Config AddNumber(String, String, String, Int64) Adds a value to a multi-valued variable in the given section and optional subsection. Declaration public abstract Config AddNumber(string section, string subsection, string variable, long value) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.Int64 value Value add to the variable. Returns Type Description Config AddString(String, String, String, String) Adds a value to a multi-valued variable in the given section and optional subsection. Declaration public abstract Config AddString(string section, string subsection, string variable, string value) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.String value Value add to the variable. Returns Type Description Config Build(ConfigLevel) Access the configuration from a specific store. Declaration public static Config Build(ConfigLevel store) Parameters Type Name Description ConfigLevel store Returns Type Description Config Build(String) Builds configuration from the given path, which can be a directory or a file path. If ommited, the will be used. Declaration public static Config Build(string path = null) Parameters Type Name Description System.String path Returns Type Description Config Remarks The returned configuration will contain the aggregate hierarchical configuration from the given directory (or file) and any ancestor directories, plus Global and System locations. GetAll(String, String, String, String) Gets all values from a multi-valued variable from the given section and optional subsection, which optionally match the given value regular expression. Declaration public abstract IEnumerable<ConfigEntry> GetAll(string section, string subsection, string variable, string valueRegex) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to remove. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description IEnumerable < ConfigEntry > GetEntries() Gets the configuration entries in the current configuration. Declaration protected abstract IEnumerable<ConfigEntry> GetEntries() Returns Type Description IEnumerable < ConfigEntry > GetNormalizedPath(String, String, String) Gets a string variable and applies path normalization to it, resolving relative paths and normalizing directory separator characters to the current platform. Declaration public abstract string GetNormalizedPath(string section, string subsection, string variable) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to retrieve as a resolved path. Returns Type Description System.String true if the value was found, false otherwise. GetRegex(String, String) Gets all values where the key (section plus subsection and variable name) match the nameRegex and optionally also the valueRegex . Declaration public abstract IEnumerable<ConfigEntry> GetRegex(string nameRegex, string valueRegex = null) Parameters Type Name Description System.String nameRegex Regular expression to match against the key (section plus subsection and variable name). System.String valueRegex Optional regular expression to match against the variable values. Returns Type Description IEnumerable < ConfigEntry > GetSection(String, String) Gets the section and optional subsection from the configuration. Declaration public ConfigSection GetSection(string section, string subsection = null) Parameters Type Name Description System.String section The section containing the variables. System.String subsection Optional subsection containing the variables. Returns Type Description ConfigSection RemoveSection(String, String) Remove the given section from the configuration file. Declaration public abstract Config RemoveSection(string section, string subsection = null) Parameters Type Name Description System.String section The section to remove. System.String subsection Optional subsection to remove. Returns Type Description Config RenameSection(String, String, String, String) Renames a section and optional subsection. Declaration public abstract Config RenameSection(string oldSection, string oldSubsection, string newSection, string newSubsection) Parameters Type Name Description System.String oldSection The old section name to rename. System.String oldSubsection The optional old subsection to rename. System.String newSection The new section name to use. System.String newSubsection The optional new subsection to use. Returns Type Description Config SetAllBoolean(String, String, String, Boolean, String) Sets the value of all matching variables in the given section and optional subsection. Declaration public abstract Config SetAllBoolean(string section, string subsection, string variable, bool value, string valueRegex) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.Boolean value Value to assign to the matching variables. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description Config SetAllDateTime(String, String, String, DateTime, String) Sets the value of all matching variables in the given section and optional subsection. Declaration public abstract Config SetAllDateTime(string section, string subsection, string variable, DateTime value, string valueRegex) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.DateTime value Value to assign to the matching variables. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description Config SetAllNumber(String, String, String, Int64, String) Sets the value of all matching variables in the given section and optional subsection. Declaration public abstract Config SetAllNumber(string section, string subsection, string variable, long value, string valueRegex) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.Int64 value Value to assign to the matching variables. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description Config SetAllString(String, String, String, String, String) Sets the value of all matching variables in the given section and optional subsection. Declaration public abstract Config SetAllString(string section, string subsection, string variable, string value, string valueRegex) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.String value Value to assign to the matching variables. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description Config SetBoolean(String, String, String, Boolean, String) Sets the value of a variable in the given section and optional subsection. Declaration public abstract Config SetBoolean(string section, string subsection, string variable, bool value, string valueRegex) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.Boolean value Value to assign to the variable. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description Config SetDateTime(String, String, String, DateTime, String) Sets the value of a variable in the given section and optional subsection. Declaration public abstract Config SetDateTime(string section, string subsection, string variable, DateTime value, string valueRegex) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.DateTime value Value to assign to the variable. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description Config SetNumber(String, String, String, Int64, String) Sets the value of a variable in the given section and optional subsection. Declaration public abstract Config SetNumber(string section, string subsection, string variable, long value, string valueRegex) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.Int64 value Value to assign to the variable. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description Config SetString(String, String, String, String, String) Sets the value of a variable in the given section and optional subsection. Declaration public abstract Config SetString(string section, string subsection, string variable, string value, string valueRegex) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to assign. System.String value Value to assign to the variable. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description Config TryGetBoolean(String, String, String, out Boolean) Tries to retrieve a variable value from configuration. Declaration public abstract bool TryGetBoolean(string section, string subsection, string variable, out bool value) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to retrieve. System.Boolean value The variable value if found. Returns Type Description System.Boolean true if the value was found, false otherwise. TryGetDateTime(String, String, String, out DateTime) Tries to retrieve a variable value from configuration. Declaration public abstract bool TryGetDateTime(string section, string subsection, string variable, out DateTime value) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to retrieve. System.DateTime value The variable value if found. Returns Type Description System.Boolean true if the value was found, false otherwise. TryGetNumber(String, String, String, out Int64) Tries to retrieve a variable value from configuration. Declaration public abstract bool TryGetNumber(string section, string subsection, string variable, out long value) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to retrieve. System.Int64 value The variable value if found. Returns Type Description System.Boolean true if the value was found, false otherwise. TryGetString(String, String, String, out String) Tries to retrieve a variable value from configuration. Declaration public abstract bool TryGetString(string section, string subsection, string variable, out string value) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to retrieve. System.String value The variable value if found. Returns Type Description System.Boolean true if the value was found, false otherwise. Unset(String, String, String) Removes a variable from the given section and optional subsection. Declaration public abstract Config Unset(string section, string subsection, string variable) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to remove. Returns Type Description Config UnsetAll(String, String, String, String) Removes all values from a multi-valued variable from the given section and optional subsection. Declaration public abstract Config UnsetAll(string section, string subsection, string variable, string valueRegex) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String variable The variable to remove. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description Config"
  },
  "api/DotNetConfig.ConfigEntry.html": {
    "href": "api/DotNetConfig.ConfigEntry.html",
    "title": "Class ConfigEntry | .netconfig",
    "keywords": "Class ConfigEntry Represents a configuration option. Inheritance System.Object ConfigEntry Implements System.IEquatable < ConfigEntry > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : DotNetConfig Assembly : cs.temp.dll.dll Syntax public class ConfigEntry : IEquatable<ConfigEntry> Constructors ConfigEntry(String, String, String, String, Nullable<ConfigLevel>) Initializes a new instance of the ConfigEntry class with a given key, value and store level. Declaration public ConfigEntry(string section, string subsection, string name, string value, ConfigLevel? level) Parameters Type Name Description System.String section The section containing the variable. System.String subsection Optional subsection containing the variable. System.String name The variable name. System.String value The variable value. System.Nullable < ConfigLevel > level The origin store. Properties Comment Gets or sets the optional comment. Declaration public string Comment { get; set; } Property Value Type Description System.String Key Gets the key for the entry. Declaration public string Key { get; } Property Value Type Description System.String Level Gets the origin store. null if not either Global or System . Declaration public ConfigLevel? Level { get; } Property Value Type Description System.Nullable < ConfigLevel > RawValue Gets the variable raw value. Declaration public string RawValue { get; set; } Property Value Type Description System.String Section Gets the section containing the entry. Declaration public string Section { get; } Property Value Type Description System.String Subsection Gets the optional subsection containing the entry. Declaration public string Subsection { get; } Property Value Type Description System.String Variable Gets the variable name. Declaration public string Variable { get; } Property Value Type Description System.String Methods GetBoolean() Gets the typed System.Boolean value for the entry. Declaration public bool GetBoolean() Returns Type Description System.Boolean The System.Boolean corresponding to the RawValue . Exceptions Type Condition System.FormatException The RawValue cannot be converted to System.Boolean . GetDateTime() Gets the typed System.DateTime value for the entry. Declaration public DateTime GetDateTime() Returns Type Description System.DateTime The System.DateTime corresponding to the RawValue . Exceptions Type Condition System.FormatException The RawValue cannot be converted to System.DateTime . GetNumber() Gets the typed System.Int64 value for the entry. Declaration public long GetNumber() Returns Type Description System.Int64 The System.Int64 corresponding to the RawValue . Exceptions Type Condition System.FormatException The RawValue cannot be converted to System.Int64 . GetString() Gets the System.String value for the entry. Declaration public string GetString() Returns Type Description System.String The System.String from the RawValue . Exceptions Type Condition System.FormatException The RawValue cannot be converted to System.String , because it does not have a value. Implements System.IEquatable<T>"
  },
  "api/DotNetConfig.ConfigLevel.html": {
    "href": "api/DotNetConfig.ConfigLevel.html",
    "title": "Enum ConfigLevel | .netconfig",
    "keywords": "Enum ConfigLevel Specifies the level of configuration to use. Namespace : DotNetConfig Assembly : cs.temp.dll.dll Syntax public enum ConfigLevel Remarks If not provided, the default .netconfig location will be used, which is typically the current directory unless building configuration from a specific file. Fields Name Description Global The global ~/.netconfig for the current user, from the System.Environment.SpecialFolder.UserProfile location. Local Use a .netconfig.user file, instead of the default .netconfig , which allows separating local-only settings from potentially team-wide configuration files that can be checked-in source control. System The system wide .netconfig, from the System.Environment.SpecialFolder.System location."
  },
  "api/DotNetConfig.ConfigSection.html": {
    "href": "api/DotNetConfig.ConfigSection.html",
    "title": "Class ConfigSection | .netconfig",
    "keywords": "Class ConfigSection Provides access to a specific section and optional subsection. Inheritance System.Object ConfigSection Implements System.IEquatable < ConfigSection > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : DotNetConfig Assembly : cs.temp.dll.dll Syntax public class ConfigSection : IEquatable<ConfigSection> Properties Section Gets the section name. Declaration public string Section { get; } Property Value Type Description System.String Subsection Gets the subsection name (if any). Declaration public string Subsection { get; } Property Value Type Description System.String Methods AddBoolean(String, Boolean) Adds a value to a multi-valued variable in the current section/subsection. Declaration public ConfigSection AddBoolean(string variable, bool value) Parameters Type Name Description System.String variable The variable to assign. System.Boolean value Value add to the variable. Returns Type Description ConfigSection AddDateTime(String, DateTime) Adds a value to a multi-valued variable in the current section/subsection. Declaration public ConfigSection AddDateTime(string variable, DateTime value) Parameters Type Name Description System.String variable The variable to assign. System.DateTime value Value add to the variable. Returns Type Description ConfigSection AddNumber(String, Int64) Adds a value to a multi-valued variable in the current section/subsection. Declaration public ConfigSection AddNumber(string variable, long value) Parameters Type Name Description System.String variable The variable to assign. System.Int64 value Value add to the variable. Returns Type Description ConfigSection AddString(String, String) Adds a value to a multi-valued variable in the current section/subsection. Declaration public ConfigSection AddString(string variable, string value) Parameters Type Name Description System.String variable The variable to assign. System.String value Value add to the variable. Returns Type Description ConfigSection GetAll(String, String) Gets all values from a multi-valued variable from the current section/subsection, which optionally match the given value regular expression. Declaration public IEnumerable<ConfigEntry> GetAll(string variable, string valueRegex = null) Parameters Type Name Description System.String variable The variable to remove. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description IEnumerable < ConfigEntry > GetNormalizedPath(String) Gets a string variable and applies path normalization to it, resolving relative paths and normalizing directory separator characters to the current platform. Declaration public string GetNormalizedPath(string variable) Parameters Type Name Description System.String variable The variable to retrieve as a resolved path. Returns Type Description System.String true if the value was found, false otherwise. SetAllBoolean(String, Boolean, String) Sets the value of all matching variables in the current section/subsection. Declaration public ConfigSection SetAllBoolean(string variable, bool value, string valueRegex = null) Parameters Type Name Description System.String variable The variable to assign. System.Boolean value Value to assign to the matching variables. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description ConfigSection SetAllDateTime(String, DateTime, String) Sets the value of all matching variables in the current section/subsection. Declaration public ConfigSection SetAllDateTime(string variable, DateTime value, string valueRegex = null) Parameters Type Name Description System.String variable The variable to assign. System.DateTime value Value to assign to the matching variables. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description ConfigSection SetAllNumber(String, Int64, String) Sets the value of all matching variables in the current section/subsection. Declaration public ConfigSection SetAllNumber(string variable, long value, string valueRegex = null) Parameters Type Name Description System.String variable The variable to assign. System.Int64 value Value to assign to the matching variables. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description ConfigSection SetAllString(String, String, String) Sets the value of all matching variables in the current section/subsection. Declaration public ConfigSection SetAllString(string variable, string value, string valueRegex = null) Parameters Type Name Description System.String variable The variable to assign. System.String value Value to assign to the matching variables. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description ConfigSection SetBoolean(String, Boolean, String) Sets the value of a variable in the current section/subsection. Declaration public ConfigSection SetBoolean(string variable, bool value, string valueRegex = null) Parameters Type Name Description System.String variable The variable to assign. System.Boolean value Value to assign to the variable. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description ConfigSection SetDateTime(String, DateTime, String) Sets the value of a variable in the current section/subsection. Declaration public ConfigSection SetDateTime(string variable, DateTime value, string valueRegex = null) Parameters Type Name Description System.String variable The variable to assign. System.DateTime value Value to assign to the variable. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description ConfigSection SetNumber(String, Int64, String) Sets the value of a variable in the current section/subsection. Declaration public ConfigSection SetNumber(string variable, long value, string valueRegex = null) Parameters Type Name Description System.String variable The variable to assign. System.Int64 value Value to assign to the variable. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description ConfigSection SetString(String, String, String) Sets the value of a variable in the current section/subsection. Declaration public ConfigSection SetString(string variable, string value, string valueRegex = null) Parameters Type Name Description System.String variable The variable to assign. System.String value Value to assign to the variable. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description ConfigSection TryGetBoolean(String, out Boolean) Tries to retrieve a variable value from configuration. Declaration public bool TryGetBoolean(string variable, out bool value) Parameters Type Name Description System.String variable The variable to retrieve. System.Boolean value The variable value if found. Returns Type Description System.Boolean true if the value was found, false otherwise. TryGetDateTime(String, out DateTime) Tries to retrieve a variable value from configuration. Declaration public bool TryGetDateTime(string variable, out DateTime value) Parameters Type Name Description System.String variable The variable to retrieve. System.DateTime value The variable value if found. Returns Type Description System.Boolean true if the value was found, false otherwise. TryGetNumber(String, out Int64) Tries to retrieve a variable value from configuration. Declaration public bool TryGetNumber(string variable, out long value) Parameters Type Name Description System.String variable The variable to retrieve. System.Int64 value The variable value if found. Returns Type Description System.Boolean true if the value was found, false otherwise. TryGetString(String, out String) Tries to retrieve a variable value from configuration. Declaration public bool TryGetString(string variable, out string value) Parameters Type Name Description System.String variable The variable to retrieve. System.String value The variable value if found. Returns Type Description System.Boolean true if the value was found, false otherwise. Unset(String) Removes a variable from the current section/subsection. Declaration public ConfigSection Unset(string variable) Parameters Type Name Description System.String variable The variable to remove. Returns Type Description ConfigSection UnsetAll(String, String) Removes all values from a multi-valued variable from the current section/subsection. Declaration public ConfigSection UnsetAll(string variable, string valueRegex = null) Parameters Type Name Description System.String variable The variable to remove. System.String valueRegex Filter returned entries to those where the value matches the given expression. Returns Type Description ConfigSection Implements System.IEquatable<T>"
  },
  "api/DotNetConfig.html": {
    "href": "api/DotNetConfig.html",
    "title": "Namespace DotNetConfig | .netconfig",
    "keywords": "Namespace DotNetConfig Classes Config Provides access to .netconfig configuration options. ConfigEntry Represents a configuration option. ConfigSection Provides access to a specific section and optional subsection. Enums ConfigLevel Specifies the level of configuration to use."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API | .netconfig",
    "keywords": "API There are three main ways to access .netconfig values: Native API for direct access to .netconfig values Microsoft.Extensions.Configuration provider System.CommandLine for CLI apps Native API PM> Install-Package DotNetConfig The main usage for .NET tool authors consuming the DotNetConfig API is to first build a configuration from a specific path (will assume current directory if omitted): var config = Config.Build(); The resulting configuration will contain the hierarchical variables set in the current directory (or the given path), all its ancestor directories, plus global and system locations. When getting values, the supported primitives are exposed as first-class methods for Add , Get and Set , so you get quite a few usability overloads for each of Boolean , DateTime , Number and String , such as AddBoolean , GetDateTime , GetString or SetNumber : // reads from: // [mytool] // enabled = true bool? enabled = config.GetBoolean(\"mytool\", \"enabled\"); // reads from: // [mytool.editor] // path = code.exe string? path = config.GetString(\"mytool.editor\", \"path\"); // reads from: // [mytool \"src/file.txt\"] // createdOn = 2020-08-23T12:00:00Z DateTime? created = config.GetDateTime(\"mytool\", \"src/file.txt\", \"createdOn\"); // If value was not found, set it to the current datetime if (created == null) // Would create the section if it did not previously exist, and add the variable config.SetDateTime(\"mytool\", \"src/file.txt\", \"createdOn\", DateTime.Now); Alternatively you can use the TryGetXXX methods instead, to avoid checking for null return values in cases where the variable (in the requested section and optional subsection) is not found: if (!config.TryGetDateTime(\"mytool\", \"src/file.txt\", \"createdOn\", out created)) config.SetDateTime(\"mytool\", \"src/file.txt\", \"createdOn\", DateTime.Now); Since .netconfig supports multi-valued variables, you can retrieve all entries as ConfigEntry and inspect or manipulate them granularly: foreach (ConfigEntry entry in config.GetAll(\"proxy\", \"url\")) { // entry.Level allows inspecting the location where the entry was read from if (entry.Level == ConfigLevel.System) // entry came from Environment.SpecialFolder.System else if (entry.Level == ConfigLevel.Global) // entry came from Environment.SpecialFolder.UserProfile else if (entry.Level == ConfigLevel.Local) // entry came from .netconfig.user file in the current dir or an ancestor directory else // local entry from current dir .netconfig or an ancestor directory Console.WriteLine(entry.GetString()); // entry.GetBoolean(), entry.GetDateTime(), entry.GetNumber() } When writing values (via AddXXX or SetXXX ) you can optionally specify the configuration level to use for persisting the value, by passing a ConfigLevel : // writes on the global .netconfig in the user's profile //[vs \"alias\"] // comexp = run|community|exp config = config.AddString(\"vs\", \"alias\", \"comexp\", \"run|community|exp\", ConfigLevel.Global); IMPORTANT: the Config API is immutable, so if you make changes, you should update your reference to the newly updated Config, otherwise, subsequent changes would override prior ones. You can explore the entire API in the docs site . Microsoft.Extensions.Configuration PM> Install-Package DotNetConfig.Configuration Usage (in this example, also chaining other providers): var config = new ConfigurationBuilder() .AddJsonFile(...) .AddEnvironmentVariables() .AddIniFile(...) .AddDotNetConfig(); Given the following .netconfig: [serve] port = 8080 [security \"admin\"] timeout = 60 You can read both values with: string port = config[\"serve:port\"]; // == \"8080\"; string timeout = config[\"security:admin:timeout\"]; // == \"60\"; System.CommandLine Given the explicit goal of making .netconfig a first-class citizen among dotnet (global) tools, it offers excelent and seamless integration with System.CommandLine . Let's asume you create a CLI app named package which manages your local cache of packages (i.e. NuGet). You might have a couple commands, like download and prune , like so: var root = new RootCommand { new Command(\"download\") { new Argument<string>(\"id\") }, new Command(\"prune\") { new Argument<string>(\"id\"), new Option<int>(\"days\") }, }.WithConfigurableDefaults(\"package\"); The added WithConfigurableDefaults invocation means that now all arguments and options can have their default values specified in config, such as: [package] id = DotNetConfig [package \"prune\"] days = 30 Note how the id can be specified at the top level too. The integration will automatically promote configurable values to ancestor sections as long as they have compatible types (both id in download and prune commands are defined as string ). Running package -? from the command line will now pull the rendered default values from config, so you can see what will actually be used if the command is run with no values: Usage: package [options] [command] Options: --version Show version information -?, -h, --help Show help and usage information Commands: download <id> [default: DotNetConfig] prune <id> [default: DotNetConfig] And package prune -? would show: Usage: package [options] prune [<id>] Arguments: <id> [default: DotNetConfig] Options: --days <days> [default: 30] -?, -h, --help Show help and usage information Since .netconfig supports multi-valued variables, it's great for populating default values for arguments or options that can be specified more than once. By making this simple change to the argument above: new Argument<string[]>(\"id\") We can now support a configuration like the following: [package] id = DotNetConfig id = Moq id = ThisAssembly And running the command with no id argument will now cause the handler to receive all three. You can also verify that this is the case via download -? , for example: Usage: package [options] download [<id>...] Arguments: <id> [default: DotNetConfig|Moq|ThisAssembly] Options: -?, -h, --help Show help and usage information All the types supported by System.CommandLine for multiple artity arguments and options are automatically populated: arrays, IEnumerable<T> , ICollection<T> , IList<T> and List<T> . For numbers, the argument/option can be either long or int . Keep in mind that since numbers in .netconfig are always long , truncation may occur in the latter case."
  },
  "api/Microsoft.Extensions.Configuration.DotNetConfigExtensions.html": {
    "href": "api/Microsoft.Extensions.Configuration.DotNetConfigExtensions.html",
    "title": "Class DotNetConfigExtensions | .netconfig",
    "keywords": "Class DotNetConfigExtensions Extension methods for adding DotNetConfig support to Microsoft.Extensions.Configuration. Inheritance System.Object DotNetConfigExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : Microsoft.Extensions.Configuration Assembly : cs.temp.dll.dll Syntax public static class DotNetConfigExtensions Methods AddDotNetConfig(IConfigurationBuilder) Adds the DotNetConfig configuration provider to the builder . Declaration public static IConfigurationBuilder AddDotNetConfig(this IConfigurationBuilder builder) Parameters Type Name Description IConfigurationBuilder builder The to add dotnet config support to. Returns Type Description IConfigurationBuilder The . Remarks Simply invoke this method on a builder to add hierarchical dotnet-config support to your app, for example: var config = new ConfigurationBuilder().AddDotNetConfig().Build(); var ssl = config[\"http:sslVerify\"]; AddDotNetConfig(IConfigurationBuilder, String) Adds the DotNetConfig configuration provider to the builder . Declaration public static IConfigurationBuilder AddDotNetConfig(this IConfigurationBuilder builder, string path = null) Parameters Type Name Description IConfigurationBuilder builder The to add dotnet config support to. System.String path Optional path to use when building the configuration. See . If not provided, the current directory will be used. Returns Type Description IConfigurationBuilder The . Remarks Simply invoke this method on a builder to add hierarchical dotnet-config support to your app, for example: var config = new ConfigurationBuilder().AddDotNetConfig().Build(); var ssl = config[\"http:sslVerify\"];"
  },
  "api/Microsoft.Extensions.Configuration.html": {
    "href": "api/Microsoft.Extensions.Configuration.html",
    "title": "Namespace Microsoft.Extensions.Configuration | .netconfig",
    "keywords": "Namespace Microsoft.Extensions.Configuration Classes DotNetConfigExtensions Extension methods for adding DotNetConfig support to Microsoft.Extensions.Configuration."
  },
  "api/System.CommandLine.CommandLineExtensions.html": {
    "href": "api/System.CommandLine.CommandLineExtensions.html",
    "title": "Class CommandLineExtensions | .netconfig",
    "keywords": "Class CommandLineExtensions Extension methods to automatically read default values for arguments and options from .netconfig. Inheritance System.Object CommandLineExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ToString() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : System.CommandLine Assembly : cs.temp.dll.dll Syntax public static class CommandLineExtensions Remarks After invoking WithConfigurableDefaults<T>(T, String, Nullable<Config>) on a command, all its arguments and options in the entire command tree are processed according to these heuristics: Only arguments/options without a default value are processed Section matches root command name, subsection (dot - separated) for each additional nested command level(i.e. [mytool &quot;mycommand.myverb&quot;] ) All the types supported by System.CommandLine for multiple artity arguments and options are automatically populated: arrays, IEnumerable{T} , ICollection{T} , IList{T} and List{T} : .netconfig can provide multi-valued variables for those Numbers can be either int or long . Methods WithConfigurableDefaults<T>(T, String, Nullable<Config>) Register default value factories for all arguments and options in the command tree which don't have a default value already. Declaration public static T WithConfigurableDefaults<T>(this T command, string section = null, Config? configuration = null) where T : Command Parameters Type Name Description T command The command to set default values for. System.String section Optional root section for this command arguments and its tree. If not provided, the command 's Name property will be used. For a , this is the app's assembly name. System.Nullable < Config > configuration Optional pre-built configuration. If not provided, will be used to build a default configuration. Returns Type Description T The command where defaults have been applied. Type Parameters Name Description T Type of command, inferred from usage."
  },
  "api/System.CommandLine.html": {
    "href": "api/System.CommandLine.html",
    "title": "Namespace System.CommandLine | .netconfig",
    "keywords": "Namespace System.CommandLine Classes CommandLineExtensions Extension methods to automatically read default values for arguments and options from .netconfig."
  },
  "index.html": {
    "href": "index.html",
    "title": "dotnet-config | .netconfig",
    "keywords": "dotnet-config Why | What | Who | How | Format | API | CLI Why dotnet-config (or .netconfig ) provides a uniform mechanism for .NET Core tools to store and read configuration values in a predictable format which can be manipulated through a command line tool, an API and also manually in any text editor by the user. Just like git config provides a uniform way of storing settings for all git commands, the goal of dotnet-config is to foster the same level of consistency across all .NET tools. The format is (mostly) compatible with it too and therefore leverages the learnings of the git community around configuration for arbitrary tools. What dotnet-config provides the following: A well-documented file format than can be hand-edited in any text editor. A dotnet global tool to manage the configuration files (much like git config ). An API for dotnet tool authors to read/write settings. By default, configuration files are named .netconfig and support four storage levels: Local: a .netconfig.user file alongside the Default level. Default: current directory and any ancestor directories. Global: user profile directory, from System.Environment.SpecialFolder.UserProfile . System: system-wide directory, from System.Environment.SpecialFolder.System . The files are read in the order given above, with first value found taking precedence. When multiple values are read then all values of a key from all files will be returned. .netconfig.user can be used to keep local-only settings separate from team-wide settings in source control, and it's already a commonly ignored extension in .gitignore . Who The following are some of the tools that leverage .netconfig to provide flexible configuration persistence options: Learn more about how the various tools leverage .netconfig in the Who section of our docs site. How Format Example file: # .netconfig is awesome: https://dotnetconfig.org [serve] port = 8080 gzip #shorthand for gzip=true [vs \"alias\"] comexp = run|community|exp preexp = run|preview|exp [file] # example of multi-valued variables url = https://github.com/dotnet/runtime/tree/master/docs/design/features url = https://github.com/dotnet/aspnetcore/tree/master/docs ; subsections allow grouping variables [file \"docs/design/features/code-versioning.md\"] url = https://github.com/dotnet/runtime/blob/master/docs/design/features/code-versioning.md etag = 7405567... [file \"docs/APIReviewProcess.md\"] url = https://github.com/dotnet/aspnetcore/blob/master/docs/APIReviewProcess.md etag = 1e4acd7... [mytool] description = \"\\t tab and \\n newline escapes, plus \\\\ backslash are valid\" title = My tool is great # internal whitespace preserved without needing double quotes path = C:\\\\tool # backslashes always escaped, inside or outside double quotes size = 500kb # numbers can have a multiplier (case insensitive) suffix kb, mb, gb, tb max-size = 1T # the 'b' is optional. compress = true # multiple variants for boolean: true|false|yes|no|on|off|1|0 secure = yes localized = off enabled = 1 ; array like syntax for complex objects [myArray \"0\"] # indecies must be unique description = 1st item description name = Fero [myArray \"1\"] description = 2nd item description name = Jozo The syntax follows closely the git-config syntax . The # and ; characters begin comments to the end of line, blank lines are ignored. The file consists of sections and variables . A section begins with the name of the section in square brackets and continues until the next section begins. Section names are case-insensitive. Only alphanumeric characters and - are allowed in section names. Each variable must belong to some section, which means that there must be a section header before the first setting of a variable. Sections can be further divided into subsections . To begin a subsection put its name in double quotes, separated by space from the section name, in the section header, like in the example below: [section \"subsection\"] Subsection names are case sensitive and can contain any characters except newline. Doublequote \" and backslash \\ can be included by escaping them as \\\" and \\\\ , respectively. Section headers cannot span multiple lines. Variables may belong directly to a section or to a given subsection. You can have [section] if you have [section \"subsection\"] , but you don't need to. All the other lines are recognized as setting variables , in the form name = value (or just name , which is a short-hand to say that the variable is the boolean true ). Variable names are case-insensitive, allow only alphanumeric characters and - , and must start with an alphabetic character. Variables may appear multiple times; we say then that the variable is multivalued . Leading whitespaces after name = , the remainder of the line after the first comment character # or ; , and trailing whitespaces of the line are discarded unless they are enclosed in double quotes. Internal whitespaces within the value are retained verbatim. Backslash \\ characters must always be escaped with \\\\ . Double quotes must either be escaped with \\\" or be properly balanced, which causes the whitespace within to be preserved verbatim. Beside \\\" and \\\\ , only \\n for newline character (NL) and \\t for horizontal tabulation (HT, TAB) escape sequences are recognized. NOTE: when using the CLI or API, these escaping rules are applied automatically Values Values of many variables are treated as a simple string, but there are variables that take values of specific types and there are rules as to how to spell them. boolean When a variable is said to take a boolean value, many synonyms are accepted for true and false ; these are all case-insensitive. true : boolean true literals are yes , on , true , and 1 . Also, a variable defined without =<value> is taken as true . false : boolean false literals are no , off , false , 0 and the empty string. datetime Variables of this type are always parsed/written using ISO 8601 (or round-trip ) format. number The value for many variables that specify various sizes can be suffixed with k , M , G or T to mean \"scale the number by 1024\", \"by 1024x1024\", \"by 1024x1024x1024\" or \"by 1024x1024x1024x1024\" respectively. The suffix is case insensitive, and can also include the b , as in kb or MB . Array of complex objects Creation of more complex objects in array is possible via subsections. Lets say that we have following configuration object: public class WatchedProcess { public string Name { get; set; } public string ApplicationPath { get; set; } } We would like to retrieve from our configuration as IList<WatchedProcess> . Even if git-config syntax does not have direct support for this scenario, we are able to create list of complex object with subsection and ConfigurationRoot . ConfigurationRoot supports working with arrays by creating indices for items as \"subsections\". This allows us to create a section selector that picks values from the array based on the element index. For example, WatchedProcess:0:Name selects the value Name from the first item in the array. This means we can use indices as subsections and create an array of complex objects as follows: [WatchedProcesses \"0\"] # indicies must be unique ApplicationPath = \"C:\\\\MyProcessPath\\ABCD\" Name = NServiceBus.Host [WatchedProcesses \"1\"] # indicies must be unique ApplicationPath = \"C:\\\\MyProcessPath2\\ABCD\" Name = NServiceBus.Host [WatchedProcesses \"2\"] # indicies must be unique ApplicationPath = \"C:\\\\MyProcessPath2\\ABCD\" Name = NServiceBus.Host With this configuration we are able to retrieve array of complex objects in following way: var configurationBuilder = new ConfigurationBuilder(); configurationBuilder.AddDotNetConfig(); var configurationRoot = configurationBuilder.Build(); var watchedProcesses = configurationRoot.GetSection(nameof(WatchedProcess)).Get<IList<Json.Appsettings.WatchedProcess>>(); NOTE: be sure that your array items have unique index API There are three main ways to access .netconfig values: Native API for direct access to .netconfig values Microsoft.Extensions.Configuration provider System.CommandLine for CLI apps Native API PM> Install-Package DotNetConfig The main usage for .NET tool authors consuming the DotNetConfig API is to first build a configuration from a specific path (will assume current directory if omitted): var config = Config.Build(); The resulting configuration will contain the hierarchical variables set in the current directory (or the given path), all its ancestor directories, plus global and system locations. When getting values, the supported primitives are exposed as first-class methods for Add , Get and Set , so you get quite a few usability overloads for each of Boolean , DateTime , Number and String , such as AddBoolean , GetDateTime , GetString or SetNumber : // reads from: // [mytool] // enabled = true bool? enabled = config.GetBoolean(\"mytool\", \"enabled\"); // reads from: // [mytool.editor] // path = code.exe string? path = config.GetString(\"mytool.editor\", \"path\"); // reads from: // [mytool \"src/file.txt\"] // createdOn = 2020-08-23T12:00:00Z DateTime? created = config.GetDateTime(\"mytool\", \"src/file.txt\", \"createdOn\"); // If value was not found, set it to the current datetime if (created == null) // Would create the section if it did not previously exist, and add the variable config.SetDateTime(\"mytool\", \"src/file.txt\", \"createdOn\", DateTime.Now); Alternatively you can use the TryGetXXX methods instead, to avoid checking for null return values in cases where the variable (in the requested section and optional subsection) is not found: if (!config.TryGetDateTime(\"mytool\", \"src/file.txt\", \"createdOn\", out created)) config.SetDateTime(\"mytool\", \"src/file.txt\", \"createdOn\", DateTime.Now); Since .netconfig supports multi-valued variables, you can retrieve all entries as ConfigEntry and inspect or manipulate them granularly: foreach (ConfigEntry entry in config.GetAll(\"proxy\", \"url\")) { // entry.Level allows inspecting the location where the entry was read from if (entry.Level == ConfigLevel.System) // entry came from Environment.SpecialFolder.System else if (entry.Level == ConfigLevel.Global) // entry came from Environment.SpecialFolder.UserProfile else if (entry.Level == ConfigLevel.Local) // entry came from .netconfig.user file in the current dir or an ancestor directory else // local entry from current dir .netconfig or an ancestor directory Console.WriteLine(entry.GetString()); // entry.GetBoolean(), entry.GetDateTime(), entry.GetNumber() } When writing values (via AddXXX or SetXXX ) you can optionally specify the configuration level to use for persisting the value, by passing a ConfigLevel : // writes on the global .netconfig in the user's profile //[vs \"alias\"] // comexp = run|community|exp config = config.AddString(\"vs\", \"alias\", \"comexp\", \"run|community|exp\", ConfigLevel.Global); IMPORTANT: the Config API is immutable, so if you make changes, you should update your reference to the newly updated Config, otherwise, subsequent changes would override prior ones. You can explore the entire API in the docs site . Microsoft.Extensions.Configuration PM> Install-Package DotNetConfig.Configuration Usage (in this example, also chaining other providers): var config = new ConfigurationBuilder() .AddJsonFile(...) .AddEnvironmentVariables() .AddIniFile(...) .AddDotNetConfig(); Given the following .netconfig: [serve] port = 8080 [security \"admin\"] timeout = 60 You can read both values with: string port = config[\"serve:port\"]; // == \"8080\"; string timeout = config[\"security:admin:timeout\"]; // == \"60\"; System.CommandLine Given the explicit goal of making .netconfig a first-class citizen among dotnet (global) tools, it offers excelent and seamless integration with System.CommandLine . Let's asume you create a CLI app named package which manages your local cache of packages (i.e. NuGet). You might have a couple commands, like download and prune , like so: var root = new RootCommand { new Command(\"download\") { new Argument<string>(\"id\") }, new Command(\"prune\") { new Argument<string>(\"id\"), new Option<int>(\"days\") }, }.WithConfigurableDefaults(\"package\"); The added WithConfigurableDefaults invocation means that now all arguments and options can have their default values specified in config, such as: [package] id = DotNetConfig [package \"prune\"] days = 30 Note how the id can be specified at the top level too. The integration will automatically promote configurable values to ancestor sections as long as they have compatible types (both id in download and prune commands are defined as string ). Running package -? from the command line will now pull the rendered default values from config, so you can see what will actually be used if the command is run with no values: Usage: package [options] [command] Options: --version Show version information -?, -h, --help Show help and usage information Commands: download <id> [default: DotNetConfig] prune <id> [default: DotNetConfig] And package prune -? would show: Usage: package [options] prune [<id>] Arguments: <id> [default: DotNetConfig] Options: --days <days> [default: 30] -?, -h, --help Show help and usage information Since .netconfig supports multi-valued variables, it's great for populating default values for arguments or options that can be specified more than once. By making this simple change to the argument above: new Argument<string[]>(\"id\") We can now support a configuration like the following: [package] id = DotNetConfig id = Moq id = ThisAssembly And running the command with no id argument will now cause the handler to receive all three. You can also verify that this is the case via download -? , for example: Usage: package [options] download [<id>...] Arguments: <id> [default: DotNetConfig|Moq|ThisAssembly] Options: -?, -h, --help Show help and usage information All the types supported by System.CommandLine for multiple artity arguments and options are automatically populated: arrays, IEnumerable<T> , ICollection<T> , IList<T> and List<T> . For numbers, the argument/option can be either long or int . Keep in mind that since numbers in .netconfig are always long , truncation may occur in the latter case. CLI <!-- #cli --> The command line tool allows you to inspect and modify configuration files used by your dotnet tools. Installation is the same as for any other dotnet tool: > dotnet tool install -g dotnet-config Reading and writing variables don't require any special options. The following lines first write a variable value and then retrieve its value: > dotnet config mytool.myvariable myvalue > dotnet config mytool.myvariable myvalue The value is returned verbatim via the standard output, so you can assign it directly to a variable, for example. All current options from running dotnet config -? are: Usage: dotnet config [options] Location (uses all locations by default) --local use .netconfig.user file --global use global config file --system use system config file --path[=VALUE] use given config file or directory Action --get get value: name [value-regex] --get-all get all values: key [value-regex] --get-regexp get values for regexp: name-regex [value-regex] --set set value: name value [value-regex] --set-all set all matches: name value [value-regex] --add add a new variable: name value --unset remove a variable: name [value-regex] --unset-all remove all matches: name [value-regex] --remove-section remove a section: name --rename-section rename section: old-name new-name -l, --list list all -e, --edit edit the config file in an editor Other --default[=VALUE] with --get, use default value when missing entry --name-only show variable names only --type[=VALUE] value is given this type, can be 'boolean', 'datetime' or 'number' -?, -h, --help Display this help Command line parsing is done with Mono.Options so all the following variants for arguments are supported: -flag , --flag , /flag , -flag=value , --flag=value , /flag=value , -flag:value , --flag:value , /flag:value , -flag value , --flag value , /flag value . <!-- #cli --> <!-- include https://github.com/devlooped/sponsors/raw/main/footer.md -->"
  },
  "who/dotnet-eventgrid.html": {
    "href": "who/dotnet-eventgrid.html",
    "title": "dotnet-eventgrid | .netconfig",
    "keywords": "dotnet-eventgrid dotnet-eventgrid is a dotnet global tool to monitor and filter real-time event from Azure EventGrid, delivered through Azure SignalR. The tool allows configuring filters so that you can monitor the specific events comming through the SignalR connection like: [eventgrid] url = https://events.mygrid.com filter = path=MyApp/**/Login filter = eventType=*System* You can also specify whether you want to see certain event properties rendered or not in the console: [eventgrid] # properties to include in the event rendering include = EventType include = Subject # properties to exclude from event rendering exclude = data The tool is quite awesome in action, and after you have your desired .netconfig in place, you can just run eventgrid without parameters and enjoy it right-away:"
  },
  "who/dotnet-file.html": {
    "href": "who/dotnet-file.html",
    "title": "dotnet-file | .netconfig",
    "keywords": "dotnet-file The dotnet-file is a dotnet global tool for downloading and updating loose files from arbitrary URLs. It uses dotnet-config to persist the remove URLs and the associated ETags for downloaded files so that performing a dotnet file update can only download the necessary changes (if any). Sample configuration: # dotnet-file GH repo download/sync for specific subfolders [file \"docs\"] url = https://github.com/dotnet/aspnetcore/tree/master/docs url = https://github.com/dotnet/runtime/tree/master/docs/design/features [file \"docs/APIReviewProcess.md\"] url = https://github.com/dotnet/aspnetcore/blob/master/docs/APIReviewProcess.md etag = 1e4acd7e1ac446f0c6d397e1ed517c54507700b85826f64745559dfb50f2acbd [file \"docs/Artifacts.md\"] url = https://github.com/dotnet/aspnetcore/blob/master/docs/Artifacts.md etag = d663b7b460e871c6af17fc288d8bd2d893e29127acf417030254dd239ef42a68 ... [file \"docs/design/features/tiered-compilation.md\"] url = https://github.com/dotnet/runtime/blob/master/docs/design/features/tiered-compilation.md etag = 8c2706b687ea4bdaac7ba4caccf29fa529856623e292195dda4aa506e39c3d7d [file \"docs/design/features/unloadability.md\"] url = https://github.com/dotnet/runtime/blob/master/docs/design/features/unloadability.md etag = 4424103e00e2fae42e6a6a8157d139de18026f2acd5d1afd6c727af03c5affeb"
  },
  "who/dotnet-serve.html": {
    "href": "who/dotnet-serve.html",
    "title": "dotnet-serve | .netconfig",
    "keywords": "dotnet-serve The dotnet-serve is a simple command-line HTTP server. It leverages dotnet-config to augment and reuse options so they don't have to be passed in constantly via the command line as arguments. The hierarchical nature of .netconfig makes it very convenient to centralize settings related to HTTPS, certificates and others globally (either at the user or system level), so that in most cases you just have to run dotnet serve from any folder and get a consistent behavior throughout your machine. To save the options used in a particular run to the current directory's .netconfig , just append --save-options : dotnet serve -p 8080 --gzip --cors --quiet --save-options After running that command, a new .netconfig will be created (if there isn't one already there) with the following section for dotnet-serve : [serve] port = 8080 gzip cors quiet You can also add multiple header , mime type mappings and exclude-file entries can be provided as individual variables, such as: [serve] port = 8080 header = X-H1: value header = X-H2: value mime = .cs=text/plain mime = .vb=text/plain mime = .fs=text/plain exclude-file = app.config exclude-file = appsettings.json You can place those settings in any parent folder and it will be reused across all descendent folders, or they can also be saved to the global (user profile) or system locations. To easily configure these options at those levels, use the dotnet-config tool itself: dotnet config --global --set serve.port 8000 dotnet config --global --add serve.mime .csproj=text/plain This will default the port to 8000 whenever a port is not specified in the command line, and it will always add the given mime type mapping. You can open the saved .netconfig at %USERPROFILE%\\.netconfig or ~/.netconfig ."
  },
  "who/dotnet-vs.html": {
    "href": "who/dotnet-vs.html",
    "title": "dotnet-vs | .netconfig",
    "keywords": "dotnet-vs The dotnet-vs tool uses dotnet-config to persist command aliases, just like GIT aliases, that run Visual Studio (or its installer) with various switches. Any of the commands supported by the vs global tool can be saved as an alias by simply appending --save [alias] at the end of the command line arguments. Next time you need to execute the same command, you can just use vs [alias] instead. Example: Run Visual Studio Community edition's experimental instance, with activity logging enabled, save as test vs run com exp /log --save=test From that point on, the same command can be run simply with: vs test Sample configuration: [vs \"alias\"] comexp = run|community|exp preexp = run|preview|exp test = run|com|exp|/log"
  },
  "who/index.html": {
    "href": "who/index.html",
    "title": "Who uses .netconfig? | .netconfig",
    "keywords": "Who uses .netconfig? This section highlights some of the known usages of dotnet-config . If you created or use a tool that leverages dotnet-config , please consider sending a PR to add it to the who directory. In addition to a .md doc showcasing the usage, don't forget to add a corresponding entry to the toc.yml . Thanks!"
  },
  "who/reportgenerator.html": {
    "href": "who/reportgenerator.html",
    "title": "ReportGenerator | .netconfig",
    "keywords": "ReportGenerator ReportGenerator converts coverage reports generated by OpenCover, dotCover, Visual Studio, NCover, Cobertura, JaCoCo, Clover, gcov or lcov into human readable reports in various formats. It provides a dotnet global tool which supports .netconfig to configure the multitude of options that generating complex reports require, for example: [ReportGenerator] reports = coverage.xml targetdir = \"C:\\report\" reporttypes = Latex;HtmlSummary assemblyfilters = +Test;-Test classfilters = +Test2;-Test2 All the plural options can also be specified as multiple singular entries, like: [ReportGenerator] report = coverage1.xml report = coverage2.xml reporttype = Latex reporttype = HtmlSummary assemblyfilter = +Test assemblyfilter = -Test classfilter = +Test2 classfilter = -Test2 filefilter = +cs filefilter = -vb sourcedir = src sourcedir = test"
  },
  "who/sleet.html": {
    "href": "who/sleet.html",
    "title": "Sleet | .netconfig",
    "keywords": "Sleet Sleet is a static (serverless) NuGet package feed generator, which supports configuration via a JSON file as well as .netconfig . All the available settings are supported via .netconfig . Some examples are: Azure Blob Storage-based feed: [sleet \"feed\"] type = azure container = feed connectionString = \"DefaultEndpointsProtocol=https;AccountName=;AccountKey=;BlobEndpoint=\" path = https://yourStorageAccount.blob.core.windows.net/feed/ AWS S3-based feed: [sleet \"feed\"] type = s3 path = https://s3.amazonaws.com/my-bucket-feed/ bucketName = my-bucket-feed region = us-west-2 accessKeyId = IAM_ACCESS_KEY_ID secretAccessKey = IAM_SECRET_ACCESS_KEY Local directory feed: gitconfig [sleet \"myLocalFeed\"] type = local path = C:\\\\myFeed See the docs for all available settings."
  }
}